
以下所有都是针对64位机来说的.

bit
====

一个byte占8个bit,对于bit的操作就是位运算.

左移,在bit级别对一个数整体向左移动,在右边用0填充. 例如对一个整数1,二进制表示为
``1``, 向左移动一个bit,二进制就变成了``10``, 也就是十进制的2,再向左移一位,
二进制变成了``100``, 对应的十进制数是``4``, 对于左移运算, 移动n位相当于原数
乘以2的n次方, 但是如果溢出的话, 结果就不是理想情况中的结果了.

对于右移, 把原有的位移动以后, 有两种填充方式. 一种是在左边填补原来最高位的值,
这称为算术右移, 另一种方式是填补0, 称为逻辑右移.

.. code:: java

    $ cat Test.java
    class Test {
        public static void main(String[] args) {
            int i = -10;
            System.out.println(i<<1);
            System.out.println(i>>1);
            System.out.println(i>>>1);
        }
    }
    $ javac Test.java && java Test
    -20
    -5
    2147483643

``>>>`` 是逻辑运算, 在左边填充了大把的0, 所以补码认为这是正数, 而算术右移保持
了算术上的正确性, 于是就有了上面的结果.

用位运算优化
=============

cpu计算乘法很慢,原因是对于一个m位乘以n位的运算,要计算O(m * n)次, 而对于加法,
只要计算O(max(m,n))次.

所以,可以利用左移来优化乘法, 例如 11*12, 可以变成 ``11 * (2^3 + 2^2)``,
就是 ``11 << 3 + 11 << 2`` , 便会大幅度提高运算速度.
