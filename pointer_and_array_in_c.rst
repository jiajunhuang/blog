:Date: 09/27/2014

《征服C指针》笔记 - 数组和指针的微妙关系
========================================

在以前的程序中, 指针确实比数组下标访问更快,
但是现在的cpu速度更快,编译器优化更好(循环计数是编译器优化的基本内容),
为什么还有把易读的数组下标改成诸如\ ``p++``\ 、\ ``*(p+i)``\ 的形式呢？
这样真的好吗？

-  在表达式中, 无论加不加[], 数组都可以被解读成指针

-  p[i] 是\*(p+i) 的语法糖, 下表运算符原本只有这种用法,
   它和数组无关(但是这只针对在表达式中的[],
   这与在声明中的[]具有不同的意义)

-  C语言中没有多维数组, 只有数组的数组（从内存分配上可以看出)

-  特例：只有在形参时, 数组和指针才是完全相等

Another blog about pointers and array:

`tech.163.com <http://tech.163.com/05/0823/11/1RR94CAS00091589.html>`__

为了防止以后这篇好文在网络上消失, 我还是备份一下比较好:

引言

　　指针是C/C++语言的特色,而数组名与指针有太多的相似,甚至很多时候,数组名可以作为指针使用.于是乎,很多程序设计者就被搞糊涂了.而许多的大学老师,他们在C语言的教学过程中也错误得给学生讲解："数组名就是指针".很幸运,我的大学老师就是其中之一.时至今日,我日复一日地进行着C/C++项目的开发,而身边还一直充满这样的程序员,他们保留着"数组名就是指针"的误解.

　　想必这种误解的根源在于国内某著名的C程序设计教程.如果这篇文章能够纠正许多中国程序员对数组名和指针的误解,笔者就不甚欣慰了.借此文,笔者站在无数对知识如饥似渴的中国程序员之中,深深寄希望于国内的计算机图书编写者们,能以"深入探索"的思维方式和精益求精的认真态度来对待图书编写工作,但愿市面上多一些融入作者思考结晶的心血之作！

　　魔幻数组名

　　请看程序（本文程序在WIN32平台下编译）：

.. code:: c

    1. #include <iostream.h>
    2. int main(int argc, char* argv[])
    3. {
    4. 　char str[10];
    5. 　char *pStr = str;
    6. 　cout << sizeof(str) << endl;
    7. 　cout << sizeof(pStr) << endl;
    8. 　return 0;
    9. }

　　1、数组名不是指针

　　我们先来推翻"数组名就是指针"的说法,用反证法.

　　证明　数组名不是指针

　　假设：数组名是指针;

　　则：pStr和str都是指针;

　　因为：在WIN32平台下,指针长度为4;

　　所以：第6行和第7行的输出都应该为4;

　　实际情况是：第6行输出10,第7行输出4;

　　所以：假设不成立,数组名不是指针

　　2、数组名神似指针

　　上面我们已经证明了数组名的确不是指针,但是我们再看看程序的第5行.该行程序将数组名直接赋值给指针,这显得数组名又的确是个指针！

　　我们还可以发现数组名显得像指针的例子：

.. code:: c

    1. #include <string.h>
    2. #include <iostream.h>
    3. int main(int argc, char* argv[])
    4. {
    5. 　char str1[10] = "I Love U";
    6. 　char str2[10]; 
    7. 　strcpy(str2,str1);
    8. 　cout << "string array 1: " << str1 << endl;
    9. 　cout << "string array 2: " << str2 << endl;
    10.　 return 0;
    11. }

　　标准C库函数strcpy的函数原形中能接纳的两个参数都为char型指针,而我们在调用中传给它的却是两个数组名！函数输出：

.. code:: c

    string array 1: I Love U
    string array 2: I Love U

　　数组名再一次显得像指针！

　　既然数组名不是指针,而为什么到处都把数组名当指针用？于是乎,许多程序员得出这样的结论：数组名（主）是（谓）不是指针的指针（宾）.

　　整个一魔鬼.

　　揭密数组名

　　现在到揭露数组名本质的时候了,先给出三个结论：

　　(1)数组名的内涵在于其指代实体是一种数据结构,这种数据结构就是数组;

　　(2)数组名的外延在于其可以转换为指向其指代实体的指针,而且是一个指针常量;

　　(3)指向数组的指针则是另外一种变量类型（在WIN32平台下,长度为4）,仅仅意味着数组的存放地址！

　　1、数组名指代一种数据结构：数组

　　现在可以解释为什么第1个程序第6行的输出为10的问题,根据结论1,数组名str的内涵为一种数据结构,即一个长度为10的char型数组,所以sizeof(str)的结果为这个数据结构占据的内存大小：10字节.

　　再看：

::

    1. int intArray[10];
    2. cout << sizeof(intArray) ;

　　第2行的输出结果为40（整型数组占据的内存空间大小）.

　　如果C/C++程序可以这样写：

.. code:: c

    1. int[10] intArray;
    2. cout << sizeof(intArray) ;

　　我们就都明白了,intArray定义为int[10]这种数据结构的一个实例,可惜啊,C/C++目前并不支持这种定义方式.

　　2、数组名可作为指针常量

　　根据结论2,数组名可以转换为指向其指代实体的指针,所以程序1中的第5行数组名直接赋值给指针,程序2第7行直接将数组名作为指针形参都可成立.

　　下面的程序成立吗？

.. code:: c

    1. int intArray[10];
    2. intArray++;

　　读者可以编译之,发现编译出错.原因在于,虽然数组名可以转换为指向其指代实体的指针,但是它只能被看作一个指针常量,不能被修改.

| 　　而指针,不管是指向结构体、数组还是基本数据类型的指针,都不包含原始数据结构的内涵,在WIN32平台下,sizeof操作的结果都是4.
| 顺便纠正一下许多程序员的另一个误解.许多程序员以为sizeof是一个函数,而实际上,它是一个操作符,不过其使用方式看起来的确太像一个函数了.语句sizeof(int)就可以说明sizeof的确不是一个函数,因为函数接纳形参（一个变量）,世界上没有一个C/C++函数接纳一个数据类型（如int）为"形参".

　　3、数据名可能失去其数据结构内涵

　　到这里似乎数组名魔幻问题已经宣告圆满解决,但是平静的湖面上却再次掀起波浪.请看下面一段程序：

.. code:: c

    1. #include <iostream.h>
    2. void arrayTest(char str[])
    3. {
    4. 　cout << sizeof(str) << endl;
    5. }
    6. int main(int argc, char* argv[])
    7. {
    8. 　char str1[10] = "I Love U";
    9. 　arrayTest(str1); 
    10.　 return 0;
    11. }

　　程序的输出结果为4.不可能吧？

　　一个可怕的数字,前面已经提到其为指针的长度!

　　结论1指出,数据名内涵为数组这种数据结构,在arrayTest函数体内,str是数组名,那为什么sizeof的结果却是指针的长度？这是因为：

　　(1)数组名作为函数形参时,在函数体内,其失去了本身的内涵,仅仅只是一个指针;

　　(2)很遗憾,在失去其内涵的同时,它还失去了其常量特性,可以作自增、自减等操作,可以被修改.

　　所以,数据名作为函数形参时,其全面沦落为一个普通指针！它的贵族身份被剥夺,成了一个地地道道的只拥有4个字节的平民.

　　以上就是结论4.

　　结束语

　　最后,笔者再次表达深深的希望,愿我和我的同道中人能够真正以谨慎的研究态度来认真思考开发中的问题,这样才能在我们中间产生大师级的程序员,顶级的开发书籍.每次拿着美国鬼子的开发书籍,我们不免发出这样的感慨：我们落后太远了.
